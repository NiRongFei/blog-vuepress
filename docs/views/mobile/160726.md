---
title: Swift Tips
date: 2016-07-26
sidebar: false
tags:
  - swift
categories:
  - 移动端
---

### 通过字符串创建类对象

- 在 swift 中打印对象时，会发现在类型前面总会有`命名空间 +.+ 类名`;
- 在 swift 中用字符串生成类对象就需要拼接成这样的格式，才能成功生成类;
- 注意，命名空间不要加特殊符号，不然依然无法获取控制器类;

```
//获取命名空间，在info.plist文件里就是Executable file
let nameSpace = NSBundle.mainBundle().infoDictionary!["CFBundleExecutable"] as! String
//拼接成固定格式
let controller:AnyClass = NSClassFromString(nameSpace + "." + controllerName)!
//创建对象
let viewController = (controller as! UIViewController.Type).init()
```

### Swift中的Any,AnyObject,AnyClass分别代表什么

- AnyObject: 相当于 OC 中的 id, 表示所有 class 类型的数据, 所有继承与 NSObject 的类都隐式实现了 protocol AnyObject 协议, 所以他可以表示所有的 class 类型;
  > 注意: 有的时候你会发现将基本数据类型或者 enum/ struct 通过 AnyObject 来保存也不会报错, 这是因为 Swift 中很多数据类型可以和 OC 中的数据类型进行自动转换, 系统内部已经将他们转换为了 OC 的对象类型;
- Any:所有基本数据类型和 enum/ struct 都可以用 Any 来表示;
- AnyClass: 用来表示任意类的类类型(元类型);
  typealias AnyClass = AnyObject.Type .Type 用于获取类的元类型, 例如 Person.Type 就代表着获取 Person 的元类型 .self 如果通过类名调用, 那么可以获取该类的类型, 说白了就是获取自己

### Swife中如何抓取异常

在 Swift 中抓取异常需要 do，catch，try 这三个关键字;
这里举个 json 序列化的例子:

```
do {
    let path = /..路径../
    let data =/..转data../
    //编译器会要求你实行异常检测，于是在序列化前面添加try字段
    //外部包裹do，catch，显而易见出错自然会走catch
    let dicArr = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.MutableContainers)
} catch {
    // 如果抛出异常就会来到catch
}
```

### Swift中如何定义全局打印方法

由于 swift 没有宏，我们不能像 oc 那样去定义,直接在 AppDelegate 中写，反正哪里都可以用,用泛型传参,如何判断调试与发布状态呢？

1. 在 Build settings 里找到 Swift Compiler-custom Flags
2. 在 other swift flags 的 Debug 里添加两个字段"-D","DEBUG",代码中直接判断就行

```
func HJSLog<T>(message: T)
{
    #if DEBUG
        print("\(message)")
    #endif
}
```

### Swift中单例写法

在 swift 中，let 本身就只会创建一次，可以运用这个特性, let 是线程安全的

```
static let instance: NetworkTools = NetworkTools()
class func shareNetworkTools() -> NetworkTools {
    return instance
}
```

### Swift中添加点击事件方法

一般我们不公开方法会在前面添加 private,但是例如按钮点击方法，光是添加 private 是不够的,因为 swift 的方法调用是在编译时就决定了,而点击事件方法由于是来自于 runloop 中,编译器不会它一起编译进来，只有在运行时呼叫，这属于 OC 的调用方式,所以我们还需要再在方法前面加上@objc:

```
//按钮点击handle
@objc private func composeClick(){ }`
```

### Swift中使用guard与fatalError配合抛出异常

在严谨的开发中会经常用到断言,这里介绍一下 guard 与 fatalError 的配合使用达到断言的效果

```
guard let safeValue = criticalValue else {
  fatalError("criticalValue cannot be nil here")
}
someNecessaryOperation(safeValue)

if let safeValue = criticalValue {
  someNecessaryOperation(safeValue)
} else {
  fatalError("criticalValue cannot be nil here")
}

if criticalValue == nil {
  fatalError("criticalValue cannot be nil here")
}
someNecessaryOperation(criticalValue!)
```

### Swift中互斥锁

```
oc中的互斥锁：
@synchronized(self) {
    //需要执行的代码块
}

swift中的互斥锁:
objc_sync_enter(self)
//需要执行的代码块
objc_sync_exit(self)
```

### Swift中避免循环引用

```
dispatch_async(dispatch_get_global_queue(0, 0)) {[unowned self] () -> Void in
    self.view
    //添加自己的代码
}
只需要在闭包里加入[unowned self]即可
```
